{"version":3,"sources":["index.tsx"],"names":["eventEmitter","EventEmitter","appearancePreferences","NativeAppearance","initialPreferences","nativeEventEmitter","NativeEventEmitter","addListener","newAppearance","Appearance","set","colorScheme","preferences","emit","listener","AppearanceProvider","props","flex","useColorScheme","subscription","getCurrentValue","getColorScheme","subscribe","callback","eventSubscription","addChangeListener","remove"],"mappings":"ipBAAA,qDACA,yCACA,oCACA,iDAEA,iTAGA,oD,gFAGA,GAAMA,CAAAA,YAAY,CAAG,GAAIC,wBAAJ,EAArB,CAGA,GAAIC,CAAAA,qBAA4C,CAAGC,mCAAiBC,kBAApE,CAGA,GAAMC,CAAAA,kBAAkB,CAAG,GAAIC,gCAAJ,CAAuBH,kCAAvB,CAA3B,CACAE,kBAAkB,CAACE,WAAnB,CAA+B,mBAA/B,CAAoD,SAACC,aAAD,CAA0C,CAC5FC,UAAU,CAACC,GAAX,CAAeF,aAAf,EACD,CAFD,E,GAIaC,CAAAA,U,iLAa8B,CACvC,MAAOP,CAAAA,qBAAqB,CAACS,WAA7B,CACD,C,gCASUC,W,CAA0C,IAC7CD,CAAAA,WAD6C,CAC7BC,WAD6B,CAC7CD,WAD6C,CAInD,GAAIT,qBAAqB,CAACS,WAAtB,GAAsCA,WAA1C,CAAuD,CACrDT,qBAAqB,CAAG,CAAES,WAAW,CAAXA,WAAF,CAAxB,CACAX,YAAY,CAACa,IAAb,CAAkB,QAAlB,CAA4BD,WAA5B,EACD,CACF,C,4DAKwBE,Q,CAAiD,CACxE,MAAOd,CAAAA,YAAY,CAACO,WAAb,CAAyB,QAAzB,CAAmCO,QAAnC,CAAP,CACD,C,wDAOI,GAAMC,CAAAA,kBAAkB,CAAG,QAArBA,CAAAA,kBAAqB,CAACC,KAAD,QAChC,8BAAC,0CAAD,wBAA0B,KAAK,CAAE,CAAEC,IAAI,CAAE,CAAR,CAAjC,EAAkDD,KAAlD,mDADgC,EAA3B,C,8CAOA,QAASE,CAAAA,cAAT,EAA2C,CAChD,GAAMC,CAAAA,YAAY,CAAG,mBACnB,iBAAO,CACLC,eAAe,CAAE,iCAAMX,CAAAA,UAAU,CAACY,cAAX,EAAN,EADZ,CAELC,SAAS,CAAE,mBAACC,QAAD,CAAkC,CAC3C,GAAIC,CAAAA,iBAAiB,CAAGf,UAAU,CAACgB,iBAAX,CAA6BF,QAA7B,CAAxB,CACA,MAAO,kBAAMC,CAAAA,iBAAiB,CAACE,MAAlB,EAAN,EAAP,CACD,CALI,CAAP,EADmB,CAQnB,EARmB,CAArB,CAWA,MAAO,qCAAiCP,YAAjC,CAAP,CACD","sourcesContent":["import React, { useMemo } from 'react';\nimport { NativeEventEmitter } from 'react-native';\nimport { EventEmitter, EventSubscription } from 'fbemitter';\nimport { useSubscription } from 'use-subscription';\nimport { AppearancePreferences, ColorSchemeName, AppearanceListener } from './Appearance.types';\nexport * from './Appearance.types';\n\n// Native modules\nimport { NativeAppearance, NativeAppearanceProvider } from './NativeAppearance';\n\n// Initialize the user-facing event emitter\nconst eventEmitter = new EventEmitter();\n\n// Initialize preferences synchronously\nlet appearancePreferences: AppearancePreferences = NativeAppearance.initialPreferences;\n\n// Initialize the native event emitter\nconst nativeEventEmitter = new NativeEventEmitter(NativeAppearance);\nnativeEventEmitter.addListener('appearanceChanged', (newAppearance: AppearancePreferences) => {\n  Appearance.set(newAppearance);\n});\n\nexport class Appearance {\n  /**\n   * Note: Although appearance is available immediately, it may change (e.g\n   * Dark Mode) so any rendering logic or styles that depend on this should try\n   * to call this function on every render, rather than caching the value (for\n   * example, using inline styles rather than setting a value in a\n   * `StyleSheet`).\n   *\n   * Example: `const colorScheme = Appearance.get('colorScheme');`\n   *\n   * @param {string} preference Name of preference (e.g. 'colorScheme').\n   * @returns {ColorSchemeName} Value for the preference.\n   */\n  static getColorScheme(): ColorSchemeName {\n    return appearancePreferences.colorScheme;\n  }\n\n  /**\n   * This should only be called from native code by sending the\n   * appearanceChanged event.\n   *\n   * @param {object} appearancePreferences Simple string-keyed object of\n   * appearance preferences to set.\n   */\n  static set(preferences: AppearancePreferences): void {\n    let { colorScheme } = preferences;\n\n    // Don't bother emitting if it's the same value\n    if (appearancePreferences.colorScheme !== colorScheme) {\n      appearancePreferences = { colorScheme };\n      eventEmitter.emit('change', preferences);\n    }\n  }\n\n  /**\n   * Add an event handler that is fired when appearance preferences change.\n   */\n  static addChangeListener(listener: AppearanceListener): EventSubscription {\n    return eventEmitter.addListener('change', listener);\n  }\n}\n\n/**\n * Temporarily require a Provider since the upstream implementation uses root view customizations\n * to accomplish this same behavior\n */\nexport const AppearanceProvider = (props: { children: any }) => (\n  <NativeAppearanceProvider style={{ flex: 1 }} {...props} />\n);\n\n/**\n * Subscribe to color scheme updates\n */\nexport function useColorScheme(): ColorSchemeName {\n  const subscription = useMemo(\n    () => ({\n      getCurrentValue: () => Appearance.getColorScheme(),\n      subscribe: (callback: AppearanceListener) => {\n        let eventSubscription = Appearance.addChangeListener(callback);\n        return () => eventSubscription.remove();\n      },\n    }),\n    [],\n  );\n\n  return useSubscription<ColorSchemeName>(subscription);\n}\n"]}