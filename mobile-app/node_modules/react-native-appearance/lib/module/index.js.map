{"version":3,"sources":["index.tsx"],"names":["React","useMemo","NativeEventEmitter","EventEmitter","useSubscription","NativeAppearance","NativeAppearanceProvider","eventEmitter","appearancePreferences","initialPreferences","nativeEventEmitter","addListener","newAppearance","Appearance","set","colorScheme","preferences","emit","listener","AppearanceProvider","props","flex","useColorScheme","subscription","getCurrentValue","getColorScheme","subscribe","callback","eventSubscription","addChangeListener","remove"],"mappings":"qQAAA,MAAOA,CAAAA,KAAP,EAAgBC,OAAhB,KAA+B,OAA/B,CACA,OAASC,kBAAT,KAAmC,cAAnC,CACA,OAASC,YAAT,KAAgD,WAAhD,CACA,OAASC,eAAT,KAAgC,kBAAhC,CAEA,WAAc,oBAAd,CAGA,OAASC,gBAAT,CAA2BC,wBAA3B,KAA2D,oBAA3D,CAGA,GAAMC,CAAAA,YAAY,CAAG,GAAIJ,CAAAA,YAAJ,EAArB,CAGA,GAAIK,CAAAA,qBAA4C,CAAGH,gBAAgB,CAACI,kBAApE,CAGA,GAAMC,CAAAA,kBAAkB,CAAG,GAAIR,CAAAA,kBAAJ,CAAuBG,gBAAvB,CAA3B,CACAK,kBAAkB,CAACC,WAAnB,CAA+B,mBAA/B,CAAoD,SAACC,aAAD,CAA0C,CAC5FC,UAAU,CAACC,GAAX,CAAeF,aAAf,EACD,CAFD,EAIA,UAAaC,CAAAA,UAAb,uJAa2C,CACvC,MAAOL,CAAAA,qBAAqB,CAACO,WAA7B,CACD,CAfH,gCAwBaC,WAxBb,CAwBuD,IAC7CD,CAAAA,WAD6C,CAC7BC,WAD6B,CAC7CD,WAD6C,CAInD,GAAIP,qBAAqB,CAACO,WAAtB,GAAsCA,WAA1C,CAAuD,CACrDP,qBAAqB,CAAG,CAAEO,WAAW,CAAXA,WAAF,CAAxB,CACAR,YAAY,CAACU,IAAb,CAAkB,QAAlB,CAA4BD,WAA5B,EACD,CACF,CAhCH,4DAqC2BE,QArC3B,CAqC4E,CACxE,MAAOX,CAAAA,YAAY,CAACI,WAAb,CAAyB,QAAzB,CAAmCO,QAAnC,CAAP,CACD,CAvCH,0BA8CA,MAAO,IAAMC,CAAAA,kBAAkB,CAAG,QAArBA,CAAAA,kBAAqB,CAACC,KAAD,QAChC,qBAAC,wBAAD,WAA0B,KAAK,CAAE,CAAEC,IAAI,CAAE,CAAR,CAAjC,EAAkDD,KAAlD,mDADgC,EAA3B,CAOP,MAAO,SAASE,CAAAA,cAAT,EAA2C,CAChD,GAAMC,CAAAA,YAAY,CAAGtB,OAAO,CAC1B,iBAAO,CACLuB,eAAe,CAAE,iCAAMX,CAAAA,UAAU,CAACY,cAAX,EAAN,EADZ,CAELC,SAAS,CAAE,mBAACC,QAAD,CAAkC,CAC3C,GAAIC,CAAAA,iBAAiB,CAAGf,UAAU,CAACgB,iBAAX,CAA6BF,QAA7B,CAAxB,CACA,MAAO,kBAAMC,CAAAA,iBAAiB,CAACE,MAAlB,EAAN,EAAP,CACD,CALI,CAAP,EAD0B,CAQ1B,EAR0B,CAA5B,CAWA,MAAO1B,CAAAA,eAAe,CAAkBmB,YAAlB,CAAtB,CACD","sourcesContent":["import React, { useMemo } from 'react';\nimport { NativeEventEmitter } from 'react-native';\nimport { EventEmitter, EventSubscription } from 'fbemitter';\nimport { useSubscription } from 'use-subscription';\nimport { AppearancePreferences, ColorSchemeName, AppearanceListener } from './Appearance.types';\nexport * from './Appearance.types';\n\n// Native modules\nimport { NativeAppearance, NativeAppearanceProvider } from './NativeAppearance';\n\n// Initialize the user-facing event emitter\nconst eventEmitter = new EventEmitter();\n\n// Initialize preferences synchronously\nlet appearancePreferences: AppearancePreferences = NativeAppearance.initialPreferences;\n\n// Initialize the native event emitter\nconst nativeEventEmitter = new NativeEventEmitter(NativeAppearance);\nnativeEventEmitter.addListener('appearanceChanged', (newAppearance: AppearancePreferences) => {\n  Appearance.set(newAppearance);\n});\n\nexport class Appearance {\n  /**\n   * Note: Although appearance is available immediately, it may change (e.g\n   * Dark Mode) so any rendering logic or styles that depend on this should try\n   * to call this function on every render, rather than caching the value (for\n   * example, using inline styles rather than setting a value in a\n   * `StyleSheet`).\n   *\n   * Example: `const colorScheme = Appearance.get('colorScheme');`\n   *\n   * @param {string} preference Name of preference (e.g. 'colorScheme').\n   * @returns {ColorSchemeName} Value for the preference.\n   */\n  static getColorScheme(): ColorSchemeName {\n    return appearancePreferences.colorScheme;\n  }\n\n  /**\n   * This should only be called from native code by sending the\n   * appearanceChanged event.\n   *\n   * @param {object} appearancePreferences Simple string-keyed object of\n   * appearance preferences to set.\n   */\n  static set(preferences: AppearancePreferences): void {\n    let { colorScheme } = preferences;\n\n    // Don't bother emitting if it's the same value\n    if (appearancePreferences.colorScheme !== colorScheme) {\n      appearancePreferences = { colorScheme };\n      eventEmitter.emit('change', preferences);\n    }\n  }\n\n  /**\n   * Add an event handler that is fired when appearance preferences change.\n   */\n  static addChangeListener(listener: AppearanceListener): EventSubscription {\n    return eventEmitter.addListener('change', listener);\n  }\n}\n\n/**\n * Temporarily require a Provider since the upstream implementation uses root view customizations\n * to accomplish this same behavior\n */\nexport const AppearanceProvider = (props: { children: any }) => (\n  <NativeAppearanceProvider style={{ flex: 1 }} {...props} />\n);\n\n/**\n * Subscribe to color scheme updates\n */\nexport function useColorScheme(): ColorSchemeName {\n  const subscription = useMemo(\n    () => ({\n      getCurrentValue: () => Appearance.getColorScheme(),\n      subscribe: (callback: AppearanceListener) => {\n        let eventSubscription = Appearance.addChangeListener(callback);\n        return () => eventSubscription.remove();\n      },\n    }),\n    [],\n  );\n\n  return useSubscription<ColorSchemeName>(subscription);\n}\n"]}